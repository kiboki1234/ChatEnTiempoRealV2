name: Secure DevOps CI/CD Pipeline

on:
  push:
    branches: [ main, develop, test ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/frontend-ci.yml'
  pull_request:
    branches: [ test, main, dev ]
    types: [opened, synchronize, reopened]
  workflow_dispatch:

env:
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  MODEL_PATH: './models/modelo_seguridad_final.pkl'
  DEPLOY_URL: 'https://tu-app.railway.app'

jobs:

    # ========== ETAPA 1: REVISI√ìN DE SEGURIDAD CON MINER√çA DE DATOS ==========
  security-review:
    name: Revisi√≥n de Seguridad con ML
    # Ejecutar en PRs (hacia test/main) O en Pushes (a main/test/develop)
    if: |
      (github.event_name == 'pull_request' && (github.base_ref == 'test' || github.base_ref == 'main')) ||
      (github.event_name == 'push')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configurar Python para ML
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: Instalar dependencias de miner√≠a de datos
        run: |
          pip install joblib pandas numpy scikit-learn lizard
          pip install python-telegram-bot requests
      
      - name: Verificar modelo de ML
        run: |
          echo "Verificando modelo de miner√≠a de datos..."
          if [ -f "models/modelo_seguridad_final.pkl" ]; then
            echo "Modelo ML encontrado"
          else
            echo "Modelo no encontrado, usando modelo por defecto"
          fi
      
      - name: Obtener archivos modificados en el PR
        id: changed-files
        uses: tj-actions/changed-files@v42
        with:
          files: |
            **/*.py
            **/*.js
            **/*.jsx
            **/*.ts
            **/*.tsx
            **/*.java
            **/*.cpp
      
      - name: Debug Secrets
        run: |
          echo "Debug Info:"
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then echo "Token: PRESENT"; else echo "Token: NOT FOUND"; fi
          if [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then echo "ChatID: PRESENT"; else echo "ChatID: NOT FOUND"; fi
          ls -R models/ || echo "Models directory not found"
      
      - name: Notificar inicio de revisi√≥n de seguridad
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMIT_MSG: ${{ github.event_name == 'push' && github.event.head_commit.message || github.event.pull_request.title }}
        run: |
          python -c "
          import requests
          import os
          import sys
          
          token = os.environ.get('TELEGRAM_BOT_TOKEN')
          chat_id = os.environ.get('TELEGRAM_CHAT_ID')
          
          # Handle Push vs PR
          event_name = '${{ github.event_name }}'
          if event_name == 'pull_request':
              ref_info = 'PR: #${{ github.event.pull_request.number }}'
          else:
              ref_info = 'Push: ${{ github.ref_name }}'
          
          author = '${{ github.actor }}'
          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown/repo')
          commit_msg = os.environ.get('COMMIT_MSG', 'No message')
          
          from datetime import datetime, timedelta, timezone
          tz = timezone(timedelta(hours=-5))
          time_str = datetime.now(tz).strftime('%d/%m/%Y %H:%M')
          
          url = f'https://api.telegram.org/bot{token}/sendMessage'
          
          text = (
              f"üîç *Inicio de Revisi√≥n de Seguridad*\n\n"
              f"üìÇ *Repo:* `{repo}`\n"
              f"üåø *Rama:* `{ref_info}`\n"
              f"üë§ *Autor:* {author}\n"
              f"üìù *Commit:* _{commit_msg}_\n"
              f"‚è∞ *Hora:* {time_str}\n\n"
              f"‚öôÔ∏è *Estado:* ‚è≥ Analizando c√≥digo..."
          )
          
          try:
              resp = requests.post(url, json={'chat_id': chat_id, 'text': text, 'parse_mode': 'Markdown'})
              print(f'Telegram response: {resp.status_code} {resp.text}')
              resp.raise_for_status()
          except Exception as e:
              print(f'Failed to send notification: {e}')
              sys.exit(1)
          
          if not token or not chat_id:
              print("ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID is missing from environment.")
              sys.exit(1)
          "
      
      - name: Ejecutar esc√°ner de seguridad con ML
        id: security-scan
        run: |
          echo "Ejecutando an√°lisis de seguridad con modelo de miner√≠a de datos..."
          
          cat > security_scanner.py << 'EOF'
          import sys
          import json
          import joblib
          import pandas as pd
          import lizard
          import re
          import os
          from pathlib import Path
          
          MODEL_PATH = os.getenv('MODEL_PATH', 'models/modelo_seguridad_final.pkl')
          
          class SecurityScannerML:
              def __init__(self):
                  try:
                      self.model = joblib.load(MODEL_PATH)
                  except:
                      self.model = None
                  
                  self.RISK_PATTERNS = {
                      'py': [r'eval\(', r'exec\(', r'subprocess\.', r'os\.system', r'cursor\.execute'],
                      'js': [r'eval\(', r'innerHTML', r'document\.write', r'dangerouslySetInnerHTML'],
                      'ts': [r'eval\(', r'innerHTML', r'document\.write', r'dangerouslySetInnerHTML'],
                      'jsx': [r'dangerouslySetInnerHTML', r'innerHTML'],
                      'tsx': [r'dangerouslySetInnerHTML', r'innerHTML'],
                      'java': [r'Statement\s+', r'Runtime\.exec']
                  }
              
              def extract_features(self, code, filename):
                  features = {'nloc': 0, 'avg_complexity': 0, 'max_complexity': 0, 'risk_keywords': 0}
                  
                  try:
                      analysis = lizard.analyze_file.analyze_source_code(filename, code)
                      features['nloc'] = analysis.nloc
                      features['avg_complexity'] = analysis.average_cyclomatic_complexity
                      features['max_complexity'] = max([f.cyclomatic_complexity for f in analysis.function_list]) if analysis.function_list else 0
                  except:
                      features['nloc'] = len(code.split('\n'))
                  
                  ext = filename.split('.')[-1].lower()
                  lang = 'py' if ext == 'py' else ('js' if ext in ['js', 'jsx'] else ('ts' if ext in ['ts', 'tsx'] else ('java' if ext == 'java' else None)))
                  
                  if lang and lang in self.RISK_PATTERNS:
                      for pattern in self.RISK_PATTERNS[lang]:
                          if re.search(pattern, code, re.IGNORECASE):
                              features['risk_keywords'] += 1
                  
                  return features
              
              def analyze_files(self, files):
                  results = []
                  vulnerable_count = 0
                  
                  for file_path in files:
                      try:
                          with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                              code = f.read()
                          
                          features = self.extract_features(code, file_path)
                          
                          if self.model:
                              df_input = pd.DataFrame([features])
                              try:
                                  probability = self.model.predict_proba(df_input)[0][1]
                                  prediction = self.model.predict(df_input)[0]
                                  is_vulnerable = prediction == 1
                              except:
                                  probability = features['risk_keywords'] / 10.0
                                  is_vulnerable = features['risk_keywords'] > 2
                          else:
                              probability = features['risk_keywords'] / 10.0
                              is_vulnerable = features['risk_keywords'] > 2
                          
                          result = {
                              'file': file_path,
                              'status': 'VULNERABLE' if is_vulnerable else 'SECURE',
                              'risk_probability': float(probability),
                              'risk_keywords': features['risk_keywords']
                          }
                          
                          results.append(result)
                          if is_vulnerable:
                              vulnerable_count += 1
                              
                      except Exception as e:
                          results.append({
                              'file': file_path,
                              'status': 'ERROR',
                              'error': str(e)
                          })
                  
                  return results, vulnerable_count
          
          files_to_scan = []
          if os.path.exists('changed_files.txt'):
              with open('changed_files.txt', 'r') as f:
                  files_to_scan = [line.strip() for line in f if line.strip()]
          
          if not files_to_scan:
              for ext in ['*.py', '*.js', '*.jsx', '*.ts', '*.tsx', '*.java']:
                  files_to_scan.extend([str(p) for p in Path('.').rglob(ext)])
          
          files_to_scan = [f for f in files_to_scan if os.path.exists(f)]
          
          scanner = SecurityScannerML()
          results, vulnerable_count = scanner.analyze_files(files_to_scan[:50])
          
          summary = {
              'status': 'VULNERABLE' if vulnerable_count > 0 else 'SECURE',
              'risk_probability': max([r.get('risk_probability', 0) for r in results], default=0),
              'files_analyzed': len(results),
              'vulnerabilities_found': vulnerable_count,
              'details': results
          }
          
          with open('security_result.json', 'w') as f:
              json.dump(summary, f, indent=2)
          
          # Guardar outputs usando el nuevo formato
          vulnerable_files = [r['file'] for r in results if r['status'] == 'VULNERABLE']
          vulnerable_files_str = ','.join(vulnerable_files) if vulnerable_files else ''
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
              fh.write(f'is_vulnerable={str(vulnerable_count > 0).lower()}\n')
              fh.write(f'status={summary["status"]}\n')
              fh.write(f'risk_probability={summary["risk_probability"]:.2f}\n')
              fh.write(f'vulnerable_files={vulnerable_files_str}\n')
          
          print(f"\nResumen del an√°lisis de seguridad:")
          print(f"   Archivos analizados: {len(results)}")
          print(f"   Archivos vulnerables: {vulnerable_count}")
          print(f"   Estado: {summary['status']}")
          
          if vulnerable_files:
              print(f"\nArchivos vulnerables detectados:")
              for file in vulnerable_files:
                  print(f"   - {file}")
          
          sys.exit(1 if vulnerable_count > 0 else 0)
          EOF
          
          echo "${{ steps.changed-files.outputs.all_changed_files }}" > changed_files.txt
          
          python security_scanner.py
      
      - name: Comentar resultado en el PR
        id: comment-pr
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let vulnerableFiles = [];
            let totalFiles = 0;
            let vulnerabilitiesFound = 0;
            
            try {
              const result = JSON.parse(fs.readFileSync('security_result.json', 'utf8'));
              totalFiles = result.files_analyzed || 0;
              vulnerabilitiesFound = result.vulnerabilities_found || 0;
              
              vulnerableFiles = result.details.filter(file => 
                file.status === 'VULNERABLE'
              ).map(file => ({
                path: file.file,
                probability: (file.risk_probability * 100).toFixed(1) + '%',
                risk_keywords: file.risk_keywords || 0
              }));
              
            } catch (e) {
              console.error('Error reading security result:', e);
            }
            
            const isVulnerable = '${{ steps.security-scan.outputs.is_vulnerable }}' === 'true';
            const riskProb = parseFloat('${{ steps.security-scan.outputs.risk_probability }}') || 0;
            
            let vulnerableFilesList = '';
            if (vulnerableFiles.length > 0) {
              vulnerableFilesList = '### üìã Archivos Vulnerables Detectados:\n\n';
              vulnerableFiles.forEach((file, index) => {
                vulnerableFilesList += `${index + 1}. **${file.path}**\n`;
                vulnerableFilesList += `   - Probabilidad de riesgo: ${file.probability}\n`;
                vulnerableFilesList += `   - Patrones de riesgo detectados: ${file.risk_keywords}\n\n`;
              });
            }
            
            const comment = `## üîç Resultado de Revisi√≥n de Seguridad (Modelo de Miner√≠a de Datos)
            
            **Estado:** ${isVulnerable ? '‚ùå VULNERABLE' : '‚úÖ SEGURO'}
            **Probabilidad de riesgo m√°xima:** ${(riskProb * 100).toFixed(1)}%
            **Archivos analizados:** ${totalFiles}
            **Vulnerabilidades detectadas:** ${vulnerabilitiesFound}

            ${isVulnerable ? '## ‚ùå MERGE BLOQUEADO - Se requiere correcci√≥n de vulnerabilidades' : '## ‚úÖ APROBADO - El c√≥digo es seguro para continuar'}

            ${vulnerableFilesList}

            <details>
            <summary>üìä Ver detalles t√©cnicos completos</summary>

            \`\`\`json
            ${JSON.stringify(vulnerableFiles, null, 2)}
            \`\`\`
            </details>

            *Modelo de ML: Random Forest | Accuracy: >82%*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

            const label = isVulnerable ? 'fixing-required' : 'security-approved';
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: [label]
            });
      
      - name: Bloquear PR y crear issue autom√°tica
        id: block-pr
        if: steps.security-scan.outputs.is_vulnerable == 'true'
        run: |
          echo "C√≥digo vulnerable detectado. Bloqueando merge y creando issue..."
          
          # Leer archivos vulnerables del JSON
          VULNERABLE_FILES=$(python -c "
          import json
          try:
              with open('security_result.json', 'r') as f:
                  data = json.load(f)
              vuln_files = [item['file'] for item in data['details'] if item.get('status') == 'VULNERABLE']
              print(','.join(vuln_files[:10]))
          except:
              print('')
          ")
          
          FILE_LIST=""
          if [ -n "$VULNERABLE_FILES" ]; then
              IFS=',' read -ra FILES_ARRAY <<< "$VULNERABLE_FILES"
              for file in "${FILES_ARRAY[@]}"; do
                  if [ -n "$file" ]; then
                      FILE_LIST="${FILE_LIST}- \`${file}\`\\n"
                  fi
              done
          fi
          
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "{
              \"title\": \"[SECURITY] Vulnerabilidad detectada en PR #${{ github.event.pull_request.number }}\",
              \"body\": \"## üö® Vulnerabilidad Detectada\\n\\n**PR:** #${{ github.event.pull_request.number }}\\n**Rama:** ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}\\n**Estado:** ‚ùå Merge bloqueado\\n\\n### üìã Archivos vulnerables:\\n\\n${FILE_LIST}\\n\\n### üìä Detalles:\\n- Probabilidad de riesgo: $(echo \"scale=0; ${{ steps.security-scan.outputs.risk_probability }} * 100\" | bc)%\\n- M√©todo de detecci√≥n: Modelo de Miner√≠a de Datos (Random Forest)\\n- Accuracy del modelo: >82%\\n\\n### üõ†Ô∏è Acciones requeridas:\\n1. Revisar los archivos listados\\n2. Corregir las vulnerabilidades\\n3. Volver a ejecutar el pipeline\\n\",
              \"labels\": [\"security\", \"fixing-required\", \"vulnerability\"],
              \"assignees\": [\"${{ github.event.pull_request.user.login }}\"]
            }"
      
      - name: Notificar resultado de seguridad
        id: notify-security
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMIT_MSG: ${{ github.event_name == 'push' && github.event.head_commit.message || github.event.pull_request.title }}
        run: |
          python -c "
          import requests
          import json
          import os
          from datetime import datetime, timedelta, timezone
          
          token = os.environ.get('TELEGRAM_BOT_TOKEN')
          chat_id = os.environ.get('TELEGRAM_CHAT_ID')
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
          
          tz = timezone(timedelta(hours=-5))
          time_str = datetime.now(tz).strftime('%d/%m/%Y %H:%M')
          
          try:
              with open('security_result.json', 'r') as f:
                  data = json.load(f)
              
              status = data.get('status', 'UNKNOWN')
              risk_prob = data.get('risk_probability', 0)
              
              vulnerable_files = []
              for item in data.get('details', []):
                  if item.get('status') == 'VULNERABLE':
                      vulnerable_files.append(item['file'])
                      
          except Exception as e:
              status = '${{ steps.security-scan.outputs.status }}'
              risk_prob = '${{ steps.security-scan.outputs.risk_probability }}'
              vulnerable_files = []
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              if status == 'VULNERABLE':
                  message = f'*üö® VULNERABILIDAD DETECTADA*\n\n'
                  message += f'üìÇ *Repo:* `{repo}`\n'
                  message += f'üåø *Ref:* `{ref_info}`\n'
                  message += f'‚è∞ *Hora:* {time_str}\n\n'
                  message += f'‚ùå *Estado:* RECHAZADO\n'
                  message += f'‚ö†Ô∏è *Riesgo:* {float(risk_prob)*100:.1f}%\n'
                  message += f'üìÇ *Archivos:* {len(vulnerable_files)}\n\n'
                  
                  if vulnerable_files:
                      message += '*Archivos afectados:*\n'
                      for i, file_path in enumerate(vulnerable_files[:5]):
                          filename = file_path.split('/')[-1] if '/' in file_path else file_path
                          message += f'{i+1}. `{filename}`\n'
                      
                      if len(vulnerable_files) > 5:
                          message += f'... y {len(vulnerable_files)-5} m√°s\n'
                  
                  message += '\nüîí *Merge bloqueado*\nüõ†Ô∏è *Se requiere correcci√≥n inmediata*'
              else:
                  message = f'*‚úÖ C√ìDIGO SEGURO*\n\n'
                  message += f'üìÇ *Repo:* `{repo}`\n'
                  message += f'üåø *Ref:* `{ref_info}`\n'
                  message += f'‚è∞ *Hora:* {time_str}\n\n'
                  message += f'‚úÖ *Estado:* APROBADO\n'
                  message += f'üõ°Ô∏è *Riesgo:* {float(risk_prob)*100:.1f}%\n\n'
                  message += '‚úì Continuando con el pipeline CI/CD'
              
              resp = requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
              resp.raise_for_status()
          except Exception as e:
              print(f"Error sending telegram message: {e}")
              sys.exit(1)
          
          if not token or not chat_id:
              print("ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID is missing from environment.")
              sys.exit(1)
          "
    
    outputs:
      security_passed: ${{ steps.security-scan.outputs.is_vulnerable == 'false' }}
      security_status: ${{ steps.security-scan.outputs.status }}
      vulnerable_files: ${{ steps.security-scan.outputs.vulnerable_files }}
        
  # ========== ETAPA 2: BUILD Y TEST DEL FRONTEND (SOLO SI SEGURO) ==========
  build-and-test:
    name: Build & Test Frontend
    needs: security-review
    if: needs.security-review.outputs.security_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    defaults:
      run:
        working-directory: ./frontend
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Notificar inicio de build
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              message = f'üèóÔ∏è *Inicio de Build y Tests*\n\n{ref_info}\\nEstado: üî® Construyendo aplicaci√≥n...'
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then
            npm ci --legacy-peer-deps
          else
            npm install --legacy-peer-deps
          fi
      
      - name: Check for security vulnerabilities
        run: npm audit --audit-level=high
        continue-on-error: true
      
      - name: Lint code
        run: |
          npm install --save-dev eslint --no-save
          npx eslint src --ext .js,.jsx,.ts,.tsx --max-warnings 20 || echo "‚ö†Ô∏è Linting encontr√≥ warnings"
        continue-on-error: true
      
      - name: Build production
        run: npm run build
        env:
          CI: false
          GENERATE_SOURCEMAP: false
      
      - name: Check build size
        run: |
          echo "üì¶ Build size:"
          du -sh build/
          du -sh build/static/js/
          du -sh build/static/css/
      
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ matrix.node-version }}
          path: frontend/build/
          retention-days: 7
      
      - name: Upload coverage
        if: hashFiles('frontend/coverage/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: frontend-coverage-${{ matrix.node-version }}
          path: frontend/coverage/
      
      - name: Notificar resultado de tests
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          pr_number = ${{ github.event.pull_request.number }}
          job_status = '${{ job.status }}'
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              if job_status == 'success':
                  message = f'‚úÖ *Tests Exitosos*\n\n{ref_info}\\nEstado: ‚úÖ Todos los tests pasaron\\n\\n‚úì Continuando.'
              else:
                  message = f'‚ùå *Tests Fallidos*\n\n{ref_info}\\nEstado: ‚ùå Tests fallaron\\n\\n‚ö†Ô∏è Pipeline detenido.'
              
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "
    
    outputs:
      build_passed: ${{ job.status == 'success' }}

  # ========== ETAPA 2B: VERIFICACI√ìN DEL BACKEND ==========
  backend-verification:
    name: Backend Verification
    needs: security-review
    if: needs.security-review.outputs.security_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    defaults:
      run:
        working-directory: ./backend
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Notificar inicio de tests backend
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              message = f'üîô *Inicio de Tests Backend*\n\n{ref_info}\\nEstado: üß™ Ejecutando Jest...'
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run Backend Tests
        run: npm test
        env:
          NODE_ENV: test
          MONGODB_URI: mongodb://localhost:27017/test_db
          JWT_SECRET: test_secret_key
          ENCRYPTION_KEY: test_encryption_key_32_chars_longgggg
          
      - name: Notificar resultado backend
        if: always()
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          job_status = '${{ job.status }}'
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              if job_status == 'success':
                  message = f'‚úÖ *Backend Tests Exitosos*\n\n{ref_info}\\nEstado: ‚úÖ Todos los tests pasaron'
              else:
                  message = f'‚ùå *Backend Tests Fallidos*\n\n{ref_info}\\nEstado: ‚ùå Tests fallaron'
              
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "

    outputs:
      backend_passed: ${{ job.status == 'success' }}

  # ========== ETAPA 3: MERGE AUTOM√ÅTICO A TEST ==========
  merge-to-test:
    name: Merge Autom√°tico a Test
    needs: [security-review, build-and-test, backend-verification]
    if: |
      needs.security-review.outputs.security_passed == 'true' &&
      needs.build-and-test.outputs.build_passed == 'true' &&
      needs.backend-verification.outputs.backend_passed == 'true' &&
      github.event_name == 'pull_request' &&
      github.base_ref == 'test'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Merge autom√°tico a test
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git checkout test
          git pull origin test
          git merge origin/${{ github.head_ref }} --no-ff -m "Auto-merge: PR #${{ github.event.pull_request.number }} [Security Approved + Tests Passed]"
          git push origin test
      
      - name: Notificar merge exitoso
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          pr_number = ${{ github.event.pull_request.number }}
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              message = f'‚úÖ *Merge a Test Exitoso*\n\nPR: #{pr_number}\\nEstado: üîÄ Merge completado\\nRama: test\\n\\n‚úì C√≥digo listo para producci√≥n.'
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "

  # ========== ETAPA 4: LIGHTHOUSE PERFORMANCE ==========
  lighthouse:
    name: Lighthouse Performance
    needs: build-and-test
    if: needs.build-and-test.outputs.build_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
      
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-20.x
          path: frontend/build
      
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v11
        continue-on-error: true
        with:
          urls: |
            http://localhost:3000
          uploadArtifacts: true
          temporaryPublicStorage: true

  # ========== ETAPA 5: MERGE A MAIN Y DESPLIEGUE ==========
  deploy-production:
    name: Despliegue en Producci√≥n
    needs: [security-review, build-and-test, backend-verification, lighthouse]
    if: |
      needs.security-review.outputs.security_passed == 'true' &&
      needs.build-and-test.outputs.build_passed == 'true' &&
      needs.backend-verification.outputs.backend_passed == 'true' &&
      needs.backend-verification.outputs.backend_passed == 'true' &&
      ((github.event_name == 'pull_request' && github.base_ref == 'main') || (github.event_name == 'push' && github.ref == 'refs/heads/main'))
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    environment: production
    permissions:
      contents: write
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Merge autom√°tico a main
        if: github.event_name == 'pull_request'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git fetch origin
          git checkout main 2>/dev/null || git checkout -b main origin/main
          git pull origin main
          git merge origin/${{ github.head_ref }} --no-ff -m "Auto-deploy: PR #${{ github.event.pull_request.number }} [Secure Release]"
          git push origin main
      
      - name: Desplegar en Railway (ejemplo)
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: |
          echo "üöÄ Desplegando en Railway..."
          # Comando de despliegue espec√≠fico para tu proveedor
          # railway up --detach || echo "Despliegue completado"
          echo "Despliegue simulado para demostraci√≥n"
      
      - name: Notificar despliegue exitoso
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMIT_MSG: ${{ github.event.pull_request.title }}
        run: |
          python -c "
          import requests
          import os
          from datetime import datetime, timedelta, timezone
          
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          deploy_url = '${{ env.DEPLOY_URL }}'
          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
          author = '${{ github.actor }}'
          
          tz = timezone(timedelta(hours=-5))
          time_str = datetime.now(tz).strftime('%d/%m/%Y %H:%M')
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              text = (
                  f"üéâ *Despliegue en Producci√≥n Exitoso*\n\n"
                  f"üìÇ *Repo:* `{repo}`\n"
                  f"üåø *Ref:* `{ref_info}`\n"
                  f"üë§ *Autor:* {author}\n"
                  f"üöÄ *URL:* {deploy_url}\n"
                  f"‚è∞ *Hora:* {time_str}\n\n"
                  f"‚úÖ Pipeline completado exitosamente."
              )
              
              requests.post(url, json={'chat_id': chat_id, 'text': text, 'parse_mode': 'Markdown'})
          "
      
      - name: Crear release tag
        run: |
          VERSION="v$(date +%Y%m%d.%H%M)"
          git tag -a "$VERSION" -m "Release: PR #${{ github.event.pull_request.number }}"
          git push origin "$VERSION"

  # ========== ETAPA FALLBACK: NOTIFICACI√ìN DE FALLOS ==========
  notify-failure:
    name: Notificar Fallos
    if: always() && (failure() || cancelled())
    needs: [security-review, build-and-test, backend-verification, deploy-production]
    runs-on: ubuntu-latest
    
    steps:
      - name: Notificar fallo general
        if: failure()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMIT_MSG: ${{ github.event_name == 'push' && github.event.head_commit.message || github.event.pull_request.title }}
        run: |
          python -c "
          import requests
          import os
          from datetime import datetime, timedelta, timezone
          
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          workflow = '${{ github.workflow }}'
          repo = os.environ.get('GITHUB_REPOSITORY', 'unknown')
          author = '${{ github.actor }}'
          commit_msg = os.environ.get('COMMIT_MSG', 'No message')
          
          tz = timezone(timedelta(hours=-5))
          time_str = datetime.now(tz).strftime('%d/%m/%Y %H:%M')
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              text = (
                  f"‚ùå *Pipeline Fall√≥*\n\n"
                  f"üìÇ *Repo:* `{repo}`\n"
                  f"üåø *Ref:* `{ref_info}`\n"
                  f"üë§ *Autor:* {author}\n"
                  f"üìù *Commit:* _{commit_msg}_\n"
                  f"‚öôÔ∏è *Workflow:* {workflow}\n"
                  f"‚è∞ *Hora:* {time_str}\n\n"
                  f"‚ö†Ô∏è *Estado:* ‚ùå FALLO CR√çTICO - Revisar GitHub Actions."
              )
              
              requests.post(url, json={'chat_id': chat_id, 'text': text, 'parse_mode': 'Markdown'})
          "