name: Secure DevOps CI/CD Pipeline

on:
  push:
    branches: [ main, develop, test ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.github/workflows/frontend-ci.yml'
  pull_request:
    branches: [ test, main, dev ]
    types: [opened, synchronize, reopened]
  workflow_dispatch:

env:
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  MODEL_PATH: './models/modelo_seguridad_final2.pkl'
  DEPLOY_URL: 'https://tu-app.railway.app'

jobs:

    # ========== ETAPA 1: REVISI√ìN DE SEGURIDAD CON MINER√çA DE DATOS ==========
  security-review:
    name: Revisi√≥n de Seguridad con ML
    # Ejecutar en PRs (hacia test/main) O en Pushes (a main/test/develop)
    if: |
      (github.event_name == 'pull_request' && (github.base_ref == 'test' || github.base_ref == 'main')) ||
      (github.event_name == 'push')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configurar Python para ML
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'
      

      
      - name: Verificar modelo de ML
        run: |
          echo "Verificando modelo de miner√≠a de datos..."
          if [ -f "security/modelo_seguridad_final2.pkl" ]; then
            echo "Modelo ML encontrado en security/"
          else
            echo "Modelo no encontrado en security/, esto causar√° error."
            # Debug
            ls -R security/ || echo "Directorio security no encontrado"
          fi
      
      - name: Obtener archivos modificados en el PR
        id: changed-files
        uses: tj-actions/changed-files@v42
        with:
          files: |
            **/*.py
            **/*.js
            **/*.jsx
            **/*.ts
            **/*.tsx
            **/*.java
            **/*.cpp
      
      - name: Debug Secrets
        run: |
          echo "Debug Info:"
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then echo "Token: PRESENT"; else echo "Token: NOT FOUND"; fi
          if [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then echo "ChatID: PRESENT"; else echo "ChatID: NOT FOUND"; fi
          ls -R models/ || echo "Models directory not found"
      
      - name: Notificar inicio de revisi√≥n de seguridad
        if: always()
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          message="üîç *Inicio de Revisi√≥n de Seguridad*%0A%0A${ref_info}%0AAutor: ${{ github.actor }}%0AEstado: ‚è≥ Analizando c√≥digo..."
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"
      
      - name: Ejecutar esc√°ner de seguridad con ML (Modular)
        id: security-scan
        run: |
          echo "Generando lista de archivos modificados..."
          echo "${{ steps.changed-files.outputs.all_changed_files }}" > changed_files.txt
          
          echo "Instalando dependencias desde requirements.txt..."
          pip install -r requirements.txt
          
          echo "Ejecutando script modular..."
          # Pasamos la lista de archivos como argumento para seguir el est√°ndar
          # pero el script tambi√©n sabe leer changed_files.txt como fallback
          
          # NOTA: Usamos xargs para pasar los archivos si son muchos, o el archivo de texto
          # Para simplificar y evitar problemas de longitud de l√≠nea, dejaremos que el script lea el archivo txt 
          # si no se pasan argumentos, o podemos intentar pasarlos.
          # El script scanner_ci.py soporta ambos m√©todos.
          
          python security/scanner_ci.py "${{ steps.changed-files.outputs.all_changed_files }}"
      
      - name: Comentar resultado en el PR
        id: comment-pr
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let vulnerableFiles = [];
            let totalFiles = 0;
            let vulnerabilitiesFound = 0;
            
            try {
              const result = JSON.parse(fs.readFileSync('security_result.json', 'utf8'));
              totalFiles = result.files_analyzed || 0;
              vulnerabilitiesFound = result.vulnerabilities_found || 0;
              
              vulnerableFiles = result.details.filter(file => 
                file.status === 'VULNERABLE'
              ).map(file => ({
                path: file.file,
                probability: (file.risk_probability * 100).toFixed(1) + '%',
                risk_keywords: file.risk_keywords || 0
              }));
              
            } catch (e) {
              console.error('Error reading security result:', e);
            }
            
            const isVulnerable = '${{ steps.security-scan.outputs.is_vulnerable }}' === 'true';
            const riskProb = parseFloat('${{ steps.security-scan.outputs.risk_probability }}') || 0;
            
            let vulnerableFilesList = '';
            if (vulnerableFiles.length > 0) {
              vulnerableFilesList = '### üìã Archivos Vulnerables Detectados:\n\n';
              vulnerableFiles.forEach((file, index) => {
                vulnerableFilesList += `${index + 1}. **${file.path}**\n`;
                vulnerableFilesList += `   - Probabilidad de riesgo: ${file.probability}\n`;
                vulnerableFilesList += `   - Patrones de riesgo detectados: ${file.risk_keywords}\n\n`;
              });
            }
            
            const comment = `## üîç Resultado de Revisi√≥n de Seguridad (Modelo de Miner√≠a de Datos)
            
            **Estado:** ${isVulnerable ? '‚ùå VULNERABLE' : '‚úÖ SEGURO'}
            **Probabilidad de riesgo m√°xima:** ${(riskProb * 100).toFixed(1)}%
            **Archivos analizados:** ${totalFiles}
            **Vulnerabilidades detectadas:** ${vulnerabilitiesFound}

            ${isVulnerable ? '## ‚ùå MERGE BLOQUEADO - Se requiere correcci√≥n de vulnerabilidades' : '## ‚úÖ APROBADO - El c√≥digo es seguro para continuar'}

            ${vulnerableFilesList}

            <details>
            <summary>üìä Ver detalles t√©cnicos completos</summary>

            \`\`\`json
            ${JSON.stringify(vulnerableFiles, null, 2)}
            \`\`\`
            </details>

            *Modelo de ML: Random Forest | Accuracy: >82%*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

            const label = isVulnerable ? 'fixing-required' : 'security-approved';
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: [label]
            });
      
      - name: Bloquear PR y crear issue autom√°tica
        id: block-pr
        if: steps.security-scan.outputs.is_vulnerable == 'true'
        run: |
          echo "C√≥digo vulnerable detectado. Bloqueando merge y creando issue..."
          
          # Leer archivos vulnerables del JSON
          VULNERABLE_FILES=$(python -c "
          import json
          try:
              with open('security_result.json', 'r') as f:
                  data = json.load(f)
              vuln_files = [item['file'] for item in data['details'] if item.get('status') == 'VULNERABLE']
              print(','.join(vuln_files[:10]))
          except:
              print('')
          ")
          
          FILE_LIST=""
          if [ -n "$VULNERABLE_FILES" ]; then
              IFS=',' read -ra FILES_ARRAY <<< "$VULNERABLE_FILES"
              for file in "${FILES_ARRAY[@]}"; do
                  if [ -n "$file" ]; then
                      FILE_LIST="${FILE_LIST}- \`${file}\`\\n"
                  fi
              done
          fi
          
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "{
              \"title\": \"[SECURITY] Vulnerabilidad detectada en PR #${{ github.event.pull_request.number }}\",
              \"body\": \"## üö® Vulnerabilidad Detectada\\n\\n**PR:** #${{ github.event.pull_request.number }}\\n**Rama:** ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}\\n**Estado:** ‚ùå Merge bloqueado\\n\\n### üìã Archivos vulnerables:\\n\\n${FILE_LIST}\\n\\n### üìä Detalles:\\n- Probabilidad de riesgo: $(echo \"scale=0; ${{ steps.security-scan.outputs.risk_probability }} * 100\" | bc)%\\n- M√©todo de detecci√≥n: Modelo de Miner√≠a de Datos (Random Forest)\\n- Accuracy del modelo: >82%\\n\\n### üõ†Ô∏è Acciones requeridas:\\n1. Revisar los archivos listados\\n2. Corregir las vulnerabilidades\\n3. Volver a ejecutar el pipeline\\n\",
              \"labels\": [\"security\", \"fixing-required\", \"vulnerability\"],
              \"assignees\": [\"${{ github.event.pull_request.user.login }}\"]
            }"
      
      - name: Notificar resultado de seguridad
        id: notify-security
        if: always()
        run: |
          python -c "
          import requests
          import json
          
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          ref_info = 'PR: #${{ github.event.pull_request.number }}' if '${{ github.event_name }}' == 'pull_request' else 'Push: ${{ github.ref_name }}'
          
          try:
              with open('security_result.json', 'r') as f:
                  data = json.load(f)
              
              status = data.get('status', 'UNKNOWN')
              risk_prob = data.get('risk_probability', 0)
              
              vulnerable_files = []
              for item in data.get('details', []):
                  if item.get('status') == 'VULNERABLE':
                      vulnerable_files.append(item['file'])
                      
          except Exception as e:
              status = '${{ steps.security-scan.outputs.status }}'
              risk_prob = '${{ steps.security-scan.outputs.risk_probability }}'
              vulnerable_files = []
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              if status == 'VULNERABLE':
                  message = f'*üö® VULNERABILIDAD DETECTADA (Modelo V2)*\n\n'
                  message += f'{ref_info}\n'
                  message += f'Estado: ‚ùå RECHAZADO\n'
                  message += f'Riesgo m√°ximo: {float(risk_prob)*100:.1f}%\n'
                  message += f'Archivos vulnerables: {len(vulnerable_files)}\n\n'
                  
                  if vulnerable_files:
                      message += '*üìù DETALLES DE ARCHIVOS:*\n\n'
                      count = 1
                      for item in data.get('details', []):
                          if item.get('status') == 'VULNERABLE':
                              name = item.get('file', 'unknown')
                              prob = float(item.get('risk_probability', 0)) * 100
                              nloc = item.get('nloc', 0)
                              comp = item.get('complexity', 0)
                              
                              # Escape special characters for Markdown
                              display_name = name.replace('_', '\\_').replace('*', '\\*')

                              message += f'üìÇ *Archivo {count}:* {display_name}\n'
                              message += f'   ‚ö†Ô∏è Riesgo: {prob:.1f}%\n'
                              message += f'   üìè Tama√±o: {nloc} l√≠neas | üß† Complejidad: {comp}\n'
                              
                              findings = item.get('findings', [])
                              if findings:
                                  message += '   üîç *C√≥digo Detectado:*\n'
                                  message += '```python\n'
                                  for f in findings[:3]: # Limit to 3 snippets to save space
                                      line_num = f['line']
                                      content = f['content']
                                      message += f'L{line_num}: {content}\n'
                                  if len(findings) > 3:
                                      message += f'... y {len(findings)-3} m√°s'
                                  message += '```\n\n'
                              else:
                                  message += '\n'
                              count += 1
                      
                      if len(vulnerable_files) > 5:
                          message += f'_... y {len(vulnerable_files)-5} archivos m√°s_\n'
                  
                  message += '\nüîí *Merge bloqueado*\nüõ†Ô∏è *Se requiere correcci√≥n inmediata*'
              else:
                  message = f'*‚úÖ C√ìDIGO SEGURO*\n\n'
                  message += f'{ref_info}\n'
                  message += f'Estado: ‚úÖ APROBADO\n'
                  message += f'Riesgo: {float(risk_prob)*100:.1f}%\n\n'
                  message += '‚úì Continuando con el pipeline CI/CD'
              
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "
    
    outputs:
      security_passed: ${{ steps.security-scan.outputs.is_vulnerable == 'false' }}
      security_status: ${{ steps.security-scan.outputs.status }}
      vulnerable_files: ${{ steps.security-scan.outputs.vulnerable_files }}
        
  # ========== ETAPA 2: BUILD Y TEST DEL FRONTEND (SOLO SI SEGURO) ==========
  build-and-test:
    name: Build & Test Frontend
    needs: security-review
    if: needs.security-review.outputs.security_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    defaults:
      run:
        working-directory: ./frontend
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Notificar inicio de build
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          message="üèóÔ∏è *Inicio de Build y Tests*%0A%0A${ref_info}%0AEstado: üî® Construyendo aplicaci√≥n..."
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then
            npm ci --legacy-peer-deps
          else
            npm install --legacy-peer-deps
          fi
      
      - name: Check for security vulnerabilities
        run: npm audit --audit-level=high
        continue-on-error: true
      
      - name: Lint code
        run: |
          npm install --save-dev eslint --no-save
          npx eslint src --ext .js,.jsx,.ts,.tsx --max-warnings 20 || echo "‚ö†Ô∏è Linting encontr√≥ warnings"
        continue-on-error: true
      
      - name: Build production
        run: npm run build
        env:
          CI: false
          GENERATE_SOURCEMAP: false
      
      - name: Check build size
        run: |
          echo "üì¶ Build size:"
          du -sh build/
          du -sh build/static/js/
          du -sh build/static/css/
      
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ matrix.node-version }}
          path: frontend/build/
          retention-days: 7
      
      - name: Upload coverage
        if: hashFiles('frontend/coverage/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: frontend-coverage-${{ matrix.node-version }}
          path: frontend/coverage/
      
      - name: Notificar resultado de tests
        if: always()
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          if [ "${{ job.status }}" == "success" ]; then
             message="‚úÖ *Tests Exitosos*%0A%0A${ref_info}%0AEstado: ‚úÖ Todos los tests pasaron%0A%0A‚úì Continuando."
          else
             message="‚ùå *Tests Fallidos*%0A%0A${ref_info}%0AEstado: ‚ùå Tests fallaron%0A%0A‚ö†Ô∏è Pipeline detenido."
          fi
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"
    
    outputs:
      build_passed: ${{ job.status == 'success' }}

  # ========== ETAPA 2B: VERIFICACI√ìN DEL BACKEND ==========
  backend-verification:
    name: Backend Verification
    needs: security-review
    if: needs.security-review.outputs.security_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    defaults:
      run:
        working-directory: ./backend
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Notificar inicio de tests backend
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          message="üîô *Inicio de Tests Backend*%0A%0A${ref_info}%0AEstado: üß™ Ejecutando Jest..."
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run Backend Tests
        run: npm test
        env:
          NODE_ENV: test
          MONGODB_URI: mongodb://localhost:27017/test_db
          JWT_SECRET: test_secret_key
          ENCRYPTION_KEY: test_encryption_key_32_chars_longgggg
          
      - name: Notificar resultado backend
        if: always()
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          if [ "${{ job.status }}" == "success" ]; then
             message="‚úÖ *Backend Tests Exitosos*%0A%0A${ref_info}%0AEstado: ‚úÖ Todos los tests pasaron"
          else
             message="‚ùå *Backend Tests Fallidos*%0A%0A${ref_info}%0AEstado: ‚ùå Tests fallaron"
          fi
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"

    outputs:
      backend_passed: ${{ job.status == 'success' }}

  # ========== ETAPA 3: MERGE AUTOM√ÅTICO A TEST ==========
  merge-to-test:
    name: Merge Autom√°tico a Test
    needs: [security-review, build-and-test, backend-verification]
    if: |
      needs.security-review.outputs.security_passed == 'true' &&
      needs.build-and-test.outputs.build_passed == 'true' &&
      needs.backend-verification.outputs.backend_passed == 'true' &&
      github.event_name == 'pull_request' &&
      github.base_ref == 'test'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Merge autom√°tico a test
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git checkout test
          git pull origin test
          git merge origin/${{ github.head_ref }} --no-ff -m "Auto-merge: PR #${{ github.event.pull_request.number }} [Security Approved + Tests Passed]"
          git push origin test
      
      - name: Notificar merge exitoso
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          pr_number = ${{ github.event.pull_request.number }}
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              message = f'‚úÖ *Merge a Test Exitoso*\n\nPR: #{pr_number}\\nEstado: üîÄ Merge completado\\nRama: test\\n\\n‚úì C√≥digo listo para producci√≥n.'
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "

  # ========== ETAPA 4: LIGHTHOUSE PERFORMANCE ==========
  lighthouse:
    name: Lighthouse Performance
    needs: build-and-test
    if: needs.build-and-test.outputs.build_passed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
      
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-20.x
          path: frontend/build
      
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v11
        continue-on-error: true
        with:
          urls: |
            http://localhost:3000
          uploadArtifacts: true
          temporaryPublicStorage: true

  # ========== ETAPA 5: MERGE A MAIN Y DESPLIEGUE ==========
  deploy-production:
    name: Despliegue en Producci√≥n
    needs: [security-review, build-and-test, backend-verification, lighthouse]
    if: |
      needs.security-review.outputs.security_passed == 'true' &&
      needs.build-and-test.outputs.build_passed == 'true' &&
      needs.backend-verification.outputs.backend_passed == 'true' &&
      github.event_name == 'pull_request' &&
      github.base_ref == 'main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    environment: production
    permissions:
      contents: write
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Merge autom√°tico a main
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git fetch origin
          git checkout main 2>/dev/null || git checkout -b main origin/main
          git pull origin main
          git merge origin/${{ github.head_ref }} --no-ff -m "Auto-deploy: PR #${{ github.event.pull_request.number }} [Secure Release]"
          git push origin main
      
      - name: Desplegar en Railway (ejemplo)
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: |
          echo "üöÄ Desplegando en Railway..."
          # Comando de despliegue espec√≠fico para tu proveedor
          # railway up --detach || echo "Despliegue completado"
          echo "Despliegue simulado para demostraci√≥n"
      
      - name: Notificar despliegue exitoso
        run: |
          python -c "
          import requests
          token = '${{ env.TELEGRAM_BOT_TOKEN }}'
          chat_id = '${{ env.TELEGRAM_CHAT_ID }}'
          pr_number = '${{ github.event.pull_request.number }}'
          deploy_url = '${{ env.DEPLOY_URL }}'
          
          if token and chat_id:
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              message = f'üéâ *Despliegue en Producci√≥n Exitoso*\n\nPR: #{pr_number}\\nEstado: üöÄ EN PRODUCCI√ìN\\nURL: {deploy_url}\\n\\n‚úÖ Pipeline completado exitosamente.'
              requests.post(url, json={'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'})
          "
      
      - name: Crear release tag
        run: |
          VERSION="v$(date +%Y%m%d.%H%M)"
          git tag -a "$VERSION" -m "Release: PR #${{ github.event.pull_request.number }}"
          git push origin "$VERSION"

  # ========== ETAPA FALLBACK: NOTIFICACI√ìN DE FALLOS ==========
  notify-failure:
    name: Notificar Fallos
    if: always() && (failure() || cancelled())
    needs: [security-review, build-and-test, backend-verification, deploy-production]
    runs-on: ubuntu-latest
    
    steps:
      - name: Notificar fallo general
        if: failure()
        run: |
          token="${{ env.TELEGRAM_BOT_TOKEN }}"
          chat_id="${{ env.TELEGRAM_CHAT_ID }}"
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ref_info="PR: #${{ github.event.pull_request.number }}"
          else
            ref_info="Push: ${{ github.ref_name }}"
          fi
          
          message="‚ùå *Pipeline Fall√≥*%0A%0A${ref_info}%0AWorkflow: ${{ github.workflow }}%0AEstado: ‚ùå FALLO%0A%0A‚ö†Ô∏è Revisar los logs de GitHub Actions."
          
          curl -s -X POST "https://api.telegram.org/bot${token}/sendMessage" \
            -d chat_id="${chat_id}" \
            -d text="${message}" \
            -d parse_mode="Markdown"